# "Наследование"

На самом деле это не совсем наследование, а скорее расширение и дополнение функциональности блока.

    const parentBlock = de.block( ... );

    const childBlock = parentBlock.extend( {
        block: {
            //  Модификации блока.
        },
        options: {
            //  Модификации опций блока.
        },
    } );


## `options.params`, `options.before`, `options.after`, `options.error`

Для каждого `options.*` и параметров блока отдельно описано, как они наследуются.
Здесь показано, как все это работает в связке.

Блок выполняется примерно в таком порядке:

      |
      v
    params --------
      |           |
      v           |
    before -------v
      |           |
      v           |
    action -------v
      |           |
      v           v
    after       error

Если мы расширяем блок, то схема усложняется до такой:

      |
      v
    child.params ---------------------------
      |                                    |
      v                                    |
    child.before --------------------------v
      |                                    |
      v                                    |
    parent.params --------                 |
      |                  |                 |
      v                  |                 |
    parent.before -------v                 |
      |                  |                 |
      v                  |                 |
    action --------------v                 |
      |                  |                 |
      v                  v                 |
    parent.after      parent.error --------v
      |                                    |
      v                                    v
    child.after                       child.error

Т.е. для потомка схема такая же, как для обычного блока, но:

  * В качестве экшена у него весь родительский блок целиком (как черный яшик).

  * В каждом "слое" используется свой `error`. Т.е. ошибки из `parent.*` сперва попадают в `parent.error`.
    И оттуда уже в `child.error`. А ошибки в `child.*` попадают сразу в `child.error` и родитель ничего про них не знает.

  * Параметры, которые используются в каждом "слое" так же разные. В `child.params` приходят оригинальные параметры из `de.run`.
    То, что вернулось оттуда используется в `child.*`. Они же подаются на вход в `parent.params` и то, что вернулось оттуда
    используется во всех `parent.*` и в экшене.

