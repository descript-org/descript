# `options.after`

Тут все как в [options.before](./options_before.md), только наоборот.
Если экшен блока завершился успешно, вызывается хук `after`.

При помощи `after` можно:

  * Изменить возвращаемое блоком значение.
  * Передумать и вернуть таки ошибку.
  * Сделать все это же, но асинхронно (вернув промис).
  * Вернуть другой блок.
  * Выполнить какие-то дополнительные действия (выставить куки, например).


## Вернуть другое значение

```js
options: {
    after: ( { result } ) => {
        //  Модифицируем результат.
        //
        return {
            ...result,
            foo: 42,
        };
    },
},
```


## Вернуть ошибку

```js
options: {
    after: ( { result } ) => {
        if ( !result.foo ) {
            //  Что-то пошло не так, результат нас не устраивает.
            //  Кидаем ошибку.
            //
            throw de.error( {
                id: 'INVALID_RESULT',
            } );
        }
    },
},
```


## Асинхронный after

Тут так же, как и в `options.before`. Можно вернуть промис, дождемся его результатов, дальше как в синхронном варианте.


## Вернуть другой блок

```js
options: {
    after: ( { result } ) => {
        if ( !result.foo ) {
            return another_block;
        }

        return result;
    },
},
```


## Выставить куки

```js
options: {
    after: ( { result, context } ) => {
        if ( result.foo ) {
            const { res } = context;

            //  Выставляем в ответ куки (например, сессионные и т.д.)
            //
            res.cookie( 'foo', result.foo, ... );
        }
    },
},
```


## Аргументы `options.after`

```js
options: {
    after: ( { params, context, deps, cancel, result } ) => {

    },
},
```


## Наследование

Здесь порядок выполнения хуков такой: сперва родительский `after`, затем `after` потомка.

```js
const parent = de.block( {
    options: {
        //  Если экшен блока успешно завершился, то выполнится родительский after.
        //  И в result придет результат экшена.
        //
        after: ( { result } ) => {
            return {
                //  Возвращаем новый результат.
                //
                ...result,
                foo: 42,
            };
        },
    },
} );

const child = parent( {
    options: {
        //  Если родительский after отработал без ошибок и вернул что-то,
        //  то это что-то приходит в after потомка в качестве результата.
        //
        after: ( { result } ) => {
            return {
                ...result,
                bar: 24,
            };
        },
    },
} );

de.run( child, ... );
```

Т.е. цепочка `after` (которая может быть длиннее двух элементов) работает начиная со старейшего предка, ему на вход попадает результат экшена.
Каждый следующий элемент получает на вход результат работы предыдущего. И результат последнего уже становится финальным результатом работы блока.
Если где-то в этой цепочке происходит ошибка (`throw` или любая другая), то весь этот процесс сразу завершается и эта ошибка отправляется в [options.error](./options_error.md).
