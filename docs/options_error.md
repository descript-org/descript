# `options.error`

Это как [options.after](./options_after.md), но опять наоборот.
Если где-то в процессе выполнения блока произошла ошибка, то мы всегда попадаем в `options.error`.
Здесь мы можем:

  * Поменять ошибку на другую.
  * Передумать и вместо ошибки вернуть результат (не ошибку).
  * То же самое, но асинхронно.


## Вернуть другую ошибку

```js
options: {
    error: ( { error } ) => {
        //  Какая-то неправильная ошибка.
        //  Возвращаем другую взамен.
        //
        if ( error.error.id === 'SOME_ERROR' ) {
            throw de.error( {
                id: 'ANOTHER_ERROR',
            } );
        }

    },
},
```


## Вернуть вместо ошибки результат

```js
options: {
    error: ( { error } ) => {
        if ( error.error.id === 'SOME_ERROR' ) {
            //  На самом деле это только так кажется, что это ошибка!
            //  Возвращаем результат.
            //
            return {
                foo: 42,
            };
        }
    },
},
```


## Асинхронный `options.error`

Можем вернуть промис, дальше как обычно.


## Аргументы `options.error`

```js
options: {
    error: ( { params, context, deps, cancel, error } ) => {

    },
},
```


## Наследование

Цепочка из `options.error` работает так же, как и `options.error`.
Но. Тут наоборот, если предыдущий элемент кидает ошибку, то она приходит в аргументе в поле `error`
в следующий элемент цепочки. А если возвращает не `undefined`, то это считается результатом работы блока
и, как обычно, он попадает в [options.after](./options_after.md).


## Ошибка `de.ERROR_ID.TOO_MANY_AFTERS_OR_ERRORS`

```js
options: {
    after: () => { throw Error(); },
    error: () => null,
}
```

Вот этот код потенциально мог бы зациклиться.
Как бы не выполнялся блок, мы в конце концов попадем либо в `after`, либо в `error`.
Из `error` мы всегда возвращаем не `undefined`, значит это новый результат работы блока и он уходит в `after`.
А из `after` мы всегда кидаем ошибку и значит попадаем обратно в `error`.

Чтобы зацикливания не случалось, `descript` считает количество итераций в цепочке `error -> after -> error -> ...`.
И если их больше N (в данный момент 3), то блок окончательно и бесповоротно заканчивается с ошибкой с id `de.ERROR_ID.TOO_MANY_AFTERS_OR_ERRORS`.
