# Фазы выполнения блока

Примерная последовательность выполнения блока:

```
                      START
                      |
                      v
                      deps ------------->|
                      |                  |
                      v                  v
                      params ----------->|
                      |                  |
                      v                  v
        |<----------- before ----------->|
        |             |                  |
        |             v                  |
        |<----------- read from cache    |
        |             |                  |
        |             v                  v
        |             action ----------->|
        |             |                  |
        |             v                  |
        |             write to cache     |
        |             |                  |
        |             v                  v
        |-----------> after <----------> error
                      |                  |
                      |                  |
                      v                  v
                      SUCCESS            ERROR

```

На схеме видно, что в целом на почти любом шаге возможно возникновение ошибки,
в этом случае мы попадаем в [options.error](./options_error.md).
Ниже особо отмечены только пункты, где **не может быть** ошибки.

Кроме того, каких-то шагов может не быть, если они не заданы соответствующими [options](./options.md).
По факту, обязателен на этой схеме только экшен.

  * Начинаем с [зависимостей](./deps.md).

  * Если они успешно разрезолвлены, то мы [вычисляем новые параметры](./options_params.md).

  * Уже с новыми параметрами мы попадаем в хук [options.before](./options_before.md).
    Тут развилка. Если мы вернули не `undefined` из `before`,
    то пропускаем несколько шагов и попадаем сразу в `after` ниже.

  * Если `before` вернул `undefined`, пытаемся прочитать данные из [кэша](./cache.md).
    Тут опять развилка. Если мы успешно прочитали что-то,
    то опять пропускаем несколько шагов и попадаем в `after`.
    Ошибки при чтении из кэша просто игнорируются, никаких последствий на последовательность
    выполнения они не имеют.

  * Если из кэша ничего прочитать не смогли, то приступаем собственно к экшену блока.
    Для [http-блока](./http_block.md), например, это http-запрос и т.д.
    Для каждого типа блока (`de.http`, `de.func`, `de.array`, `de.object`) экшен свой.

  * Если у нас были заданы параметры для [кэширования](./cache.md) (`options.key`, `options.maxage` и `options.cache`),
    то записываем в кэш успешный результат экшена.
    Ошибки записи в кэш опять же игнорируются и, если запись асинхронная,
    то не ждем окончания записи.

  * Тут мы в итоге попадаем в хук [options.after](./options_after.md).
    Здесь финальная развилка. Если `after` не кидает ошибку, то все завершается **УСПЕХОМ**.

  * На всех предыдущих шагах мы могли попасть в хук [options.error](./options_error.md).
    Где у нас есть последний шанс на то, чтобы превратить ошибку в не ошибку.
    Тут опять развилка. Если `error` возвращает не `undefined`, то мы забываем про ошибку и,
    как ни в чем не бывало, идем с этим в `after`.
    Если же `error` возвращает `undefined` или кидает новую ошибку, то все. Это **ПРОВАЛ**.

Тут `options.after` и `options.error` симметричны друг другу. Мы можем превратить ошибку в результат (`error -> after`),
или наоборот, превратить результат в ошибку (`after -> error`).
Могло бы [зациклиться, но нет](./options_error.md#ошибка-deerror_idtoo_many_afters_or_errors).

